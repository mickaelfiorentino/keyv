-------------------------------------------------------------------------------
-- Project : KeyV
-- File    : keyring.vhd
-- Author  : Mickael Fiorentino <mickael.fiorentino@polymtl.ca>
-- Lab     : GRM - Polytechnique Montreal
-- Date    : 2020-02-20
-- Brief   : Self-timed clocks generated by a 2D torus mesh
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.utils_pkg.all;
use work.keyv_pkg.all;

entity keyring is
  port (
    i_rstn    : in  std_logic;
    i_clk     : in  std_logic;
    i_keyring : in  keyv_to_keyring;
    o_keyring : out keyv_from_keyring);
end entity keyring;

architecture str of keyring is

  signal iclicks        : keyv_to_click_m;
  signal oclicks        : keyv_from_click_m;
  signal keys_c         : keyv_logic_m;
  signal keys_d         : keyv_logic_m;
  signal keys_c_del     : keyv_logic_m;
  signal states         : keyv_logic_m;
  signal delay_cfg      : keyv_delay_cfg;
  signal k_delays       : keyv_delay_m;
  signal m_delays_mul   : keyv_delay;
  signal m_delays_start : keyv_delay;
  signal m_delays_stop  : keyv_delay;
  signal m_iclick       : keyv_to_click;
  signal m_oclick       : keyv_from_click;
  signal m_key_c_del    : keyv_logic;
  signal m_start        : keyv_logic;
  signal m_startd       : keyv_logic;
  signal m_stop         : keyv_logic;
  signal m_stopd        : keyv_logic;
  signal m_start_clk    : keyv_logic;
  signal m_stop_clk     : keyv_logic;

begin

  ------------------------------------------------------------------------------
  -- Resources clocks
  --
  --    Resources clocks (r_clks) are connected to shared resources
  --    For each stage, all XU clocks are ORed together
  ------------------------------------------------------------------------------
  g_rclk: for s in 0 to KEYRING_S-1 generate
    p_rclk : process(all)
      variable rclk : std_logic;
    begin
      rclk := '0';
      for e in 0 to KEYRING_E-1 loop
        if oclicks(e)(s).clk = '1' then
          rclk := '1';
        end if;
      end loop;
      o_keyring.r_clks(s) <= rclk;
    end process p_rclk;
  end generate g_rclk;

  ------------------------------------------------------------------------------
  -- Delay Elements Configuration
  --
  --    Registers containing the DE configurations
  --    Meant to be loaded sequentially (scan) during reset time
  ------------------------------------------------------------------------------
  p_delays: process (i_clk)
  begin
    if rising_edge(i_clk) then
      if (i_rstn = '0' and i_keyring.delay_en = '1') then
        delay_cfg(0) <= i_keyring.delay_cfg;
        for i in 1 to KEYRING_DE_FLAT-1 loop
          delay_cfg(i) <= delay_cfg(i-1);
        end loop;
      end if;
    end if;
  end process p_delays;

  ------------------------------------------------------------------------------
  -- KEYRING
  ------------------------------------------------------------------------------
  gE : for e in 0 to KEYRING_E-1 generate
    gS : for s in 0 to KEYRING_S-1 generate

      --------------------------------------------------------------------------
      -- Clocks, Keys, States
      --
      --    Clocks: Each clock is connected to a given stage of a given XU
      --    Keys  : Link the clicks together in a 2D torus mesh (KeyRing)
      --            Delayed throuh DCDL
      --    States: Phase conversion of the Keys used to control XBS muxes
      --            init_condition() controls the inversion of some keys.
      --    key_c : Key on clock path. Q output of the toggle-flop
      --    key_d : Key on data path: QN output of the toggle-flop (inverted)
      --            Same logic than key_c, but allow to separate timing paths
      --------------------------------------------------------------------------
      o_keyring.clks(e)(s)   <= oclicks(e)(s).clk;
      o_keyring.states(e)(s) <= states(e)(s);
      keys_c(e)(s)           <= oclicks(e)(s).key_c;
      keys_d(e)(s)           <= oclicks(e)(s).key_d;

      g_state: if click_concurrency(e,s) = 0 generate
        states(e)(s) <= keys_d(e)(s) xnor keys_d(get_click(e-1, KEYRING_E))(s);
      end generate g_state;
      g_nstate: if click_concurrency(e,s) > 0 generate
        states(e)(s) <= keys_d(e)(s) xor keys_d(get_click(e-1, KEYRING_E))(s);
      end generate g_nstate;

      --------------------------------------------------------------------------
      -- Click Element
      --
      --    There are E x S clicks in the KeyRing, linked together by keys
      --------------------------------------------------------------------------
      u_click : click
        generic map (
          E => e,
          S => s)
        port map (
          i_rstn  => i_rstn,
          i_click => iclicks(e)(s),
          o_click => oclicks(e)(s));

      iclicks(e)(s).key_e <= keys_c_del(get_click(e, KEYRING_E))(get_click(s-1, KEYRING_S));
      iclicks(e)(s).key_s <= keys_c_del(get_click(e-1, KEYRING_E))(get_click(s+KEYRING_D-1, KEYRING_S));

      --------------------------------------------------------------------------
      -- Delay Elements
      --
      --    keyd is the delayed version of keys.
      --    Delays for each key comes from the delay_cfg registers
      --------------------------------------------------------------------------
      g_delays : for i in KEYRING_L-1 downto 0 generate
        k_delays(e)(s)(KEYRING_L-1-i) <= delay_cfg(KEYRING_L*(e*KEYRING_S + s)+i);
      end generate g_delays;

      u_dcdl: dcdl
        generic map (
          DL => KEYRING_L)
        port map (
          o_logic => keys_c_del(e)(s),
          i_logic => keys_c(e)(s),
          i_sel   => k_delays(e)(s));

    end generate gS;
  end generate gE;

  ------------------------------------------------------------------------------
  -- STALLS
  ------------------------------------------------------------------------------
  g_stalls_E : for i in 0 to KEYRING_E-1 generate
    g_stalls_S : for j in 0 to KEYRING_S-1 generate

      gnE : if j /= keyv_clk'pos(E) generate
        iclicks(i)(j).stall <= i_keyring.stalls(i)(j);
      end generate gnE;

      gE : if j = keyv_clk'pos(E) generate
        iclicks(i)(j).stall <= (i_keyring.stalls(i)(j) or (states(i)(j) and (m_start xor m_stopd)));
      end generate gE;

    end generate g_stalls_S;
  end generate g_stalls_E;

  ------------------------------------------------------------------------------
  -- MUL / DIV Clock
  --
  --     Standalone 1 x 1 KeyRing used to generate the mul/div unit clock
  --     It starts/ends with the stall input. MU_delay is the clock period
  --     u_dcdl_m_start is the DE matching the first stage of the FSM
  --     u_dcdl_m is the DE matching the stages of the FSM
  --     u_dcdl_m_stop is the DE matching the final stage of the FSM
  ------------------------------------------------------------------------------
  o_keyring.m_clk <= m_oclick.clk;
  m_iclick.key_e  <= m_key_c_del;
  m_iclick.key_s  <= m_key_c_del;
  m_iclick.stall  <= m_startd xnor m_stop;

  g_m_delays : for i in 0 to KEYRING_L-1 generate
    m_delays_mul(KEYRING_L-1-i)   <= delay_cfg(KEYRING_L*(KEYRING_E*KEYRING_S+2)+i);
    m_delays_start(KEYRING_L-1-i) <= delay_cfg(KEYRING_L*(KEYRING_E*KEYRING_S+1)+i);
    m_delays_stop(KEYRING_L-1-i)  <= delay_cfg(KEYRING_L*(KEYRING_E*KEYRING_S+0)+i);
  end generate g_m_delays;

  u_click_m : click
    generic map (
      E => 0,
      S => 0)
    port map (
      i_rstn  => i_rstn,
      i_click => m_iclick,
      o_click => m_oclick);

  u_dcdl_m : dcdl
    generic map (
      DL => KEYRING_L)
    port map (
      o_logic => m_key_c_del,
      i_logic => m_oclick.key_c,
      i_sel   => m_delays_mul);

  m_start_clk <= i_keyring.m_start;
  m_stop_clk  <= i_keyring.m_stop;

  p_m_start: process (i_rstn, m_start_clk)
  begin
    if i_rstn = '0' then
      m_start <= '1';
    elsif rising_edge(m_start_clk) then
      m_start <= not m_stop;
    end if;
  end process p_m_start;

  u_dcdl_m_start : dcdl
    generic map (
      DL => KEYRING_L)
    port map (
      o_logic => m_startd,
      i_logic => m_start,
      i_sel   => m_delays_start);

  u_dcdl_m_stop : dcdl
    generic map (
      DL => KEYRING_L)
    port map (
      o_logic => m_stopd,
      i_logic => m_stop,
      i_sel   => m_delays_stop);

  p_m_stop: process (i_rstn, m_stop_clk)
  begin
    if i_rstn = '0' then
      m_stop <= '1';
    elsif rising_edge(m_stop_clk) then
      m_stop <= m_startd;
    end if;
  end process p_m_stop;

end architecture str;
